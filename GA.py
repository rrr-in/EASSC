# -*- coding: utf-8 -*-
"""Copy of FPKel2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O4ZDC3bvFCwB_RWhyd7bd1cYfwgIaPBo
"""

import pandas as pd
import numpy as np
import random
import re
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from math import radians, cos, sin, asin, sqrt

# --- 1. Load Data ---
nodes_df = pd.read_csv('nodes.csv')
# Distance matrix
# Note: The file name in the VM is 'DATA FIX TAMAN.xlsx - Jarak Tempuh.csv'
dist_df_raw = pd.read_excel('DATA FIX TAMAN.xlsx', sheet_name='Jarak Tempuh', header=2, index_col=0)

# Vehicles
# The file name in the VM is 'DATA FIX TAMAN.xlsx - Data Kendaraan.csv'
vehicles_df_raw = pd.read_excel('DATA FIX TAMAN.xlsx', sheet_name='Data Kendaraan', header=None)

# --- 2. Process Vehicles (Siang/Malam) ---
siang_idx = -1
malam_idx = -1

for i, row in vehicles_df_raw.iterrows():
    row_str = str(row.values).lower()
    if 'siang' in row_str and siang_idx == -1:
        siang_idx = i
    if 'malam' in row_str and malam_idx == -1:
        malam_idx = i

def normalize_plate(plate):
    if not isinstance(plate, str): return ""
    plate = plate.replace('.', ' ').upper()
    plate = " ".join(plate.split())
    if plate.startswith('L') and len(plate) > 1 and plate[1].isdigit():
        plate = 'L ' + plate[1:]
    match = re.search(r'(\d+)\s*([A-Z]+)$', plate)
    if match:
        number = match.group(1)
        suffix = match.group(2)
        prefix = plate.split(number)[0]
        plate = f"{prefix}{number} {suffix}"
    return " ".join(plate.split())

def extract_vehicles(start_row, end_row, df):
    vehicles = []
    limit = end_row if end_row != -1 else len(df)
    subset = df.iloc[start_row+1:limit]
    # Column 2 has license plates
    potential_vehicles = subset.iloc[:, 2].dropna().tolist()
    for v in potential_vehicles:
        v_str = str(v).strip()
        if len(v_str) < 20 and any(char.isdigit() for char in v_str) and 'penyiraman' not in v_str.lower():
             norm_v = normalize_plate(v_str)
             if norm_v: vehicles.append(norm_v)
    return vehicles

vehicles_siang = []
vehicles_malam = []
if siang_idx != -1:
    end = malam_idx if malam_idx != -1 else -1
    vehicles_siang = extract_vehicles(siang_idx, end, vehicles_df_raw)
if malam_idx != -1:
    vehicles_malam = extract_vehicles(malam_idx, -1, vehicles_df_raw)

# Build Ordered Shift List
active_vehicles_ordered = []
for v in vehicles_siang:
    active_vehicles_ordered.append({'name': v, 'shift': 'Siang'})
for v in vehicles_malam:
    active_vehicles_ordered.append({'name': v, 'shift': 'Malam'})

print(f"Loaded {len(active_vehicles_ordered)} vehicles from Shift Schedule.")

# --- 3. Build Distance Matrix & Parameters ---
num_nodes = 88
dist_matrix = np.zeros((num_nodes, num_nodes))

# Fill from file
for i in range(1, num_nodes):
    for j in range(1, num_nodes):
        try:
            val = dist_df_raw.loc[i, str(j)]
            dist_matrix[i, j] = val
        except KeyError: pass

# Fill Depot (0) using Haversine
depot = nodes_df[nodes_df['id'] == 0].iloc[0]
def haversine(lon1, lat1, lon2, lat2):
    lon1, lat1, lon2, lat2 = map(radians, [lon1, lat1, lon2, lat2])
    dlon = lon2 - lon1
    dlat = lat2 - lat1
    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
    c = 2 * asin(sqrt(a))
    r = 6371
    return c * r

for i in range(1, num_nodes):
    node = nodes_df[nodes_df['id'] == i].iloc[0]
    d = haversine(depot.lon, depot.lat, node.lon, node.lat)
    dist_matrix[0, i] = d
    dist_matrix[i, 0] = d

# Park & Refill Data
park_nodes = nodes_df[nodes_df['type'] == 'park']
park_ids = park_nodes['id'].tolist()
park_demands_map = dict(zip(park_nodes['id'], park_nodes['demand_liters']))
refill_ids = nodes_df[nodes_df['type'] == 'refill']['id'].values
VEHICLE_CAPACITY = 5000

# --- 4. Genetic Algorithm (Optimize Sequence) ---
# Objective: Minimize total distance of the relay sequence
def get_relay_distance(park_sequence):
    total_dist = 0
    current_water = 0
    current_node = 0

    # Virtual simulation to calculate distance
    demand_queue = [{'id': pid, 'qty': park_demands_map[pid]} for pid in park_sequence]
    current_park_idx = 0

    while current_park_idx < len(demand_queue):
        target = demand_queue[current_park_idx]
        target_id = target['id']
        required = target['qty']

        if current_water <= 0:
            # New Trip: Depot -> Refill -> Park
            # Find best refill
            best_r = -1
            min_detour = float('inf')
            # From Depot(0) to Refill to Target
            for r in refill_ids:
                d = dist_matrix[0, int(r)] + dist_matrix[int(r), target_id]
                if d < min_detour:
                    min_detour = d
                    best_r = int(r)
            total_dist += min_detour
            current_water = VEHICLE_CAPACITY
            current_node = target_id
        else:
            # Park to Park
            total_dist += dist_matrix[current_node, target_id]
            current_node = target_id

        amount = min(current_water, required)
        current_water -= amount
        demand_queue[current_park_idx]['qty'] -= amount

        if demand_queue[current_park_idx]['qty'] <= 0:
            current_park_idx += 1

        if current_water <= 0:
            # End of vehicle shift -> Return to Depot
            total_dist += dist_matrix[current_node, 0]
            current_node = 0

    if current_node != 0:
        total_dist += dist_matrix[current_node, 0]

    return total_dist

# GA Params
POP_SIZE = 50
GENERATIONS = 40
MUTATION_RATE = 0.2
random.seed(42)

def create_individual():
    ind = park_ids[:]
    random.shuffle(ind)
    return ind

def mutate(ind):
    if random.random() < MUTATION_RATE:
        i, j = random.sample(range(len(ind)), 2)
        ind[i], ind[j] = ind[j], ind[i]
    return ind

def crossover(p1, p2):
    size = len(p1)
    a, b = sorted(random.sample(range(size), 2))
    child = [-1]*size
    child[a:b] = p1[a:b]
    ptr = b
    for gene in p2:
        if gene not in child:
            if ptr >= size: ptr = 0
            child[ptr] = gene
            ptr += 1
    return child

# Run GA
population = [create_individual() for _ in range(POP_SIZE)]
best_fitness = float('inf')
best_ind = None

print("Running GA Optimization...")
for gen in range(GENERATIONS):
    scores = [(get_relay_distance(ind), ind) for ind in population]
    scores.sort(key=lambda x: x[0])

    if scores[0][0] < best_fitness:
        best_fitness = scores[0][0]
        best_ind = scores[0][1][:]

    # Elitism
    next_pop = [x[1] for x in scores[:10]]
    while len(next_pop) < POP_SIZE:
        parents = random.sample(scores[:20], 2)
        child = crossover(parents[0][1], parents[1][1])
        child = mutate(child)
        next_pop.append(child)
    population = next_pop

print(f"GA Optimization Complete. Best Distance: {best_fitness:.2f} km")

# --- 5. Generate Relay Solution (Assign Vehicles) ---
log_rows = []
vehicle_idx = 0
current_water = 0
current_node = 0
demand_queue = [{'id': pid, 'qty': park_demands_map[pid], 'name': nodes_df[nodes_df['id']==pid].iloc[0]['name']} for pid in best_ind]
trip_step = 1

def get_current_vehicle_info(idx):
    if not active_vehicles_ordered: return "Unknown", "Unknown"
    v_data = active_vehicles_ordered[idx % len(active_vehicles_ordered)]
    return v_data['name'], v_data['shift']

v_name, v_shift = get_current_vehicle_info(vehicle_idx)
log_rows.append({'Vehicle': v_name, 'Shift': v_shift, 'Step': 0, 'Location': 'Depot', 'Action': 'Start Shift', 'Water': 0, 'Distance': 0})

current_park_idx = 0

while current_park_idx < len(demand_queue):
    target = demand_queue[current_park_idx]
    target_id = target['id']
    required = target['qty']
    target_name = target['name']

    dist_leg = 0

    if current_water <= 0:
        # Needs Refill Trip
        # Depot -> Refill -> Target
        best_r = -1
        min_detour = float('inf')
        for r in refill_ids:
            d = dist_matrix[0, int(r)] + dist_matrix[int(r), target_id]
            if d < min_detour:
                min_detour = d
                best_r = int(r)

        r_name = nodes_df[nodes_df['id'] == best_r].iloc[0]['name']
        dist_to_refill = dist_matrix[0, int(best_r)]

        # Log Start for new vehicle if needed (check logic)
        if current_node == 0 and trip_step > 1:
             v_name, v_shift = get_current_vehicle_info(vehicle_idx)
             log_rows.append({'Vehicle': v_name, 'Shift': v_shift, 'Step': trip_step, 'Location': 'Depot', 'Action': 'Start Shift', 'Water': 0, 'Distance': 0})
             trip_step += 1

        # Go to Refill
        log_rows.append({'Vehicle': v_name, 'Shift': v_shift, 'Step': trip_step, 'Location': r_name, 'Action': 'Refill', 'Water': VEHICLE_CAPACITY, 'Distance': dist_to_refill})
        trip_step += 1

        current_water = VEHICLE_CAPACITY
        current_node = target_id # Will arrive at target next
        dist_leg = dist_matrix[int(best_r), target_id]

    else:
        # Park to Park
        dist_leg = dist_matrix[current_node, target_id]
        current_node = target_id

    # Watering
    amount = min(current_water, required)
    current_water -= amount
    demand_queue[current_park_idx]['qty'] -= amount

    log_rows.append({'Vehicle': v_name, 'Shift': v_shift, 'Step': trip_step, 'Location': target_name, 'Action': f"Watering ({amount}L)", 'Water': current_water, 'Distance': dist_leg})
    trip_step += 1

    if demand_queue[current_park_idx]['qty'] <= 0:
        current_park_idx += 1

    if current_water <= 0:
        # Empty -> Return to Depot -> End Shift
        dist_home = dist_matrix[current_node, 0]
        log_rows.append({'Vehicle': v_name, 'Shift': v_shift, 'Step': trip_step, 'Location': 'Depot', 'Action': 'End Shift (Empty)', 'Water': 0, 'Distance': dist_home})
        trip_step += 1
        current_node = 0

        # Switch Vehicle
        vehicle_idx += 1
        v_name, v_shift = get_current_vehicle_info(vehicle_idx)
        # Note: New vehicle starts loop with current_water = 0, triggering Refill Trip logic.

if current_node != 0:
    dist_home = dist_matrix[current_node, 0]
    log_rows.append({'Vehicle': v_name, 'Shift': v_shift, 'Step': trip_step, 'Location': 'Depot', 'Action': 'End Shift', 'Water': current_water, 'Distance': dist_home})

final_df = pd.DataFrame(log_rows)
final_df.to_csv('solution_relay_shift_ordered.csv', index=False)
print("Solution Saved: solution_relay_shift_ordered.csv")
print(final_df.head(10))

# --- 6. Plotting ---
plt.figure(figsize=(12, 10))
plt.scatter(park_nodes['lon'], park_nodes['lat'], c='green', label='Taman', s=30, alpha=0.6)
r_nodes = nodes_df[nodes_df['type']=='refill']
plt.scatter(r_nodes['lon'], r_nodes['lat'], c='blue', marker='s', label='Refill', s=30, alpha=0.6)
plt.scatter(depot['lon'], depot['lat'], c='red', marker='*', label='Depot', s=200, zorder=10)

name_coord_map = dict(zip(nodes_df['name'], zip(nodes_df['lon'], nodes_df['lat'])))
name_coord_map['Depot'] = (depot.lon, depot.lat)

# To avoid clutter, plot a subset of vehicle paths or all with thin lines
# Group by Vehicle
unique_vehicles = final_df['Vehicle'].unique()
colors = cm.get_cmap('tab20', len(unique_vehicles))

for i, v in enumerate(unique_vehicles):
    v_data = final_df[final_df['Vehicle'] == v]
    path_lons = []
    path_lats = []

    # Trace path
    # Start at Depot (implicitly) if first step is Start Shift at Depot
    for _, row in v_data.iterrows():
        loc = row['Location']
        if loc in name_coord_map:
            path_lons.append(name_coord_map[loc][0])
            path_lats.append(name_coord_map[loc][1])

    plt.plot(path_lons, path_lats, color=colors(i), linewidth=1.5, alpha=0.7, label=v if i < 10 else None)

plt.title('Peta Rute Estafet (Shift) Penyiraman')
plt.xlabel('Longitude')
plt.ylabel('Latitude')
handles, labels = plt.gca().get_legend_handles_labels()
by_label = dict(zip(labels, handles))
plt.legend(by_label.values(), by_label.keys(), bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.grid(True, alpha=0.3)
plt.savefig('vrp_relay_map_final.png')

# ==========================================
# 7. HITUNG & TAMPILKAN TOTAL JARAK
# ==========================================
print("\n" + "="*40)
print("       RINGKASAN TOTAL JARAK")
print("="*40)

# Pastikan membaca file yang baru saja disimpan
try:
    df_result = pd.read_csv('solution_relay_shift_ordered.csv')

    # 1. Total Jarak per Kendaraan
    # Kita group berdasarkan Nama Kendaraan & Shift
    dist_per_vehicle = df_result.groupby(['Vehicle', 'Shift'])['Distance'].sum().reset_index()

    # Rename kolom biar lebih rapi
    dist_per_vehicle.rename(columns={'Distance': 'Total Jarak (km)'}, inplace=True)

    # Tampilkan tabel per kendaraan
    print("\n--- Total Jarak per Kendaraan ---")
    print(dist_per_vehicle.to_string(index=False))

    # 2. Total Jarak Keseluruhan (Optimal Route)
    total_optimal_dist = df_result['Distance'].sum()

    print("\n" + "-"*40)
    print(f"TOTAL JARAK RUTE PALING OPTIMAL: {total_optimal_dist:.2f} km")
    print("-"*40)

except FileNotFoundError:
    print("File hasil tidak ditemukan. Pastikan proses sebelumnya sukses.")
except Exception as e:
    print(f"Terjadi kesalahan saat menghitung: {e}")

"""# Task
Improve the Genetic Algorithm's optimization by increasing the number of generations, re-running the GA, re-generating the relay solution for vehicle assignments and watering steps, updating the route map visualization, and recalculating the total distance. Finally, provide a summary of the new total optimal distance and compare it with the previous result.

## Increase GA Generations

### Subtask:
Modify the `GENERATIONS` parameter in the Genetic Algorithm setup to a higher value (e.g., 100 or 200) to allow the algorithm to search for a more optimal sequence for a longer period.

**Reasoning**:
The subtask requires increasing the `GENERATIONS` parameter. I will modify the existing code to set `GENERATIONS` to 100, as specified in the instructions, and re-run the genetic algorithm.
"""

# --- 4. Genetic Algorithm (Optimize Sequence) ---
# Objective: Minimize total distance of the relay sequence
def get_relay_distance(park_sequence):
    total_dist = 0
    current_water = 0
    current_node = 0

    # Virtual simulation to calculate distance
    demand_queue = [{'id': pid, 'qty': park_demands_map[pid]} for pid in park_sequence]
    current_park_idx = 0

    while current_park_idx < len(demand_queue):
        target = demand_queue[current_park_idx]
        target_id = target['id']
        required = target['qty']

        if current_water <= 0:
            # New Trip: Depot -> Refill -> Park
            # Find best refill
            best_r = -1
            min_detour = float('inf')
            # From Depot(0) to Refill to Target
            for r in refill_ids:
                d = dist_matrix[0, int(r)] + dist_matrix[int(r), target_id]
                if d < min_detour:
                    min_detour = d
                    best_r = int(r)
            total_dist += min_detour
            current_water = VEHICLE_CAPACITY
            current_node = target_id
        else:
            # Park to Park
            total_dist += dist_matrix[current_node, target_id]
            current_node = target_id

        amount = min(current_water, required)
        current_water -= amount
        demand_queue[current_park_idx]['qty'] -= amount

        if demand_queue[current_park_idx]['qty'] <= 0:
            current_park_idx += 1

        if current_water <= 0:
            # End of vehicle shift -> Return to Depot
            total_dist += dist_matrix[current_node, 0]
            current_node = 0

    if current_node != 0:
        total_dist += dist_matrix[current_node, 0]

    return total_dist

# GA Params
POP_SIZE = 50
GENERATIONS = 100 # Modified from 40 to 100
MUTATION_RATE = 0.2
random.seed(42)

def create_individual():
    ind = park_ids[:]
    random.shuffle(ind)
    return ind

def mutate(ind):
    if random.random() < MUTATION_RATE:
        i, j = random.sample(range(len(ind)), 2)
        ind[i], ind[j] = ind[j], ind[i]
    return ind

def crossover(p1, p2):
    size = len(p1)
    a, b = sorted(random.sample(range(size), 2))
    child = [-1]*size
    child[a:b] = p1[a:b]
    ptr = b
    for gene in p2:
        if gene not in child:
            if ptr >= size: ptr = 0
            child[ptr] = gene
            ptr += 1
    return child

# Run GA
population = [create_individual() for _ in range(POP_SIZE)]
best_fitness = float('inf')
best_ind = None

print("Running GA Optimization...")
for gen in range(GENERATIONS):
    scores = [(get_relay_distance(ind), ind) for ind in population]
    scores.sort(key=lambda x: x[0])

    if scores[0][0] < best_fitness:
        best_fitness = scores[0][0]
        best_ind = scores[0][1][:]

    # Elitism
    next_pop = [x[1] for x in scores[:10]]
    while len(next_pop) < POP_SIZE:
        parents = random.sample(scores[:20], 2)
        child = crossover(parents[0][1], parents[1][1])
        child = mutate(child)
        next_pop.append(child)
    population = next_pop

print(f"GA Optimization Complete. Best Distance: {best_fitness:.2f} km")

"""**Reasoning**:
The previous step completed the Genetic Algorithm optimization with an increased number of generations. Now, I need to re-generate the relay solution (vehicle assignments and watering steps) using the `best_ind` obtained from the re-run GA to reflect the improved park sequence.


"""

# --- 5. Generate Relay Solution (Assign Vehicles) ---
log_rows = []
vehicle_idx = 0
current_water = 0
current_node = 0
demand_queue = [{'id': pid, 'qty': park_demands_map[pid], 'name': nodes_df[nodes_df['id']==pid].iloc[0]['name']} for pid in best_ind]
trip_step = 1

def get_current_vehicle_info(idx):
    if not active_vehicles_ordered: return "Unknown", "Unknown"
    v_data = active_vehicles_ordered[idx % len(active_vehicles_ordered)]
    return v_data['name'], v_data['shift']

v_name, v_shift = get_current_vehicle_info(vehicle_idx)
log_rows.append({'Vehicle': v_name, 'Shift': v_shift, 'Step': 0, 'Location': 'Depot', 'Action': 'Start Shift', 'Water': 0, 'Distance': 0})

current_park_idx = 0

while current_park_idx < len(demand_queue):
    target = demand_queue[current_park_idx]
    target_id = target['id']
    required = target['qty']
    target_name = target['name']

    dist_leg = 0

    if current_water <= 0:
        # Needs Refill Trip
        # Depot -> Refill -> Target
        best_r = -1
        min_detour = float('inf')
        for r in refill_ids:
            d = dist_matrix[0, int(r)] + dist_matrix[int(r), target_id]
            if d < min_detour:
                min_detour = d
                best_r = int(r)

        r_name = nodes_df[nodes_df['id'] == best_r].iloc[0]['name']
        dist_to_refill = dist_matrix[0, int(best_r)]

        # Log Start for new vehicle if needed (check logic)
        if current_node == 0 and trip_step > 1:
             v_name, v_shift = get_current_vehicle_info(vehicle_idx)
             log_rows.append({'Vehicle': v_name, 'Shift': v_shift, 'Step': trip_step, 'Location': 'Depot', 'Action': 'Start Shift', 'Water': 0, 'Distance': 0})
             trip_step += 1

        # Go to Refill
        log_rows.append({'Vehicle': v_name, 'Shift': v_shift, 'Step': trip_step, 'Location': r_name, 'Action': 'Refill', 'Water': VEHICLE_CAPACITY, 'Distance': dist_to_refill})
        trip_step += 1

        current_water = VEHICLE_CAPACITY
        current_node = target_id # Will arrive at target next
        dist_leg = dist_matrix[int(best_r), target_id]

    else:
        # Park to Park
        dist_leg = dist_matrix[current_node, target_id]
        current_node = target_id

    # Watering
    amount = min(current_water, required)
    current_water -= amount
    demand_queue[current_park_idx]['qty'] -= amount

    log_rows.append({'Vehicle': v_name, 'Shift': v_shift, 'Step': trip_step, 'Location': target_name, 'Action': f"Watering ({amount}L)", 'Water': current_water, 'Distance': dist_leg})
    trip_step += 1

    if demand_queue[current_park_idx]['qty'] <= 0:
        current_park_idx += 1

    if current_water <= 0:
        # Empty -> Return to Depot -> End Shift
        dist_home = dist_matrix[current_node, 0]
        log_rows.append({'Vehicle': v_name, 'Shift': v_shift, 'Step': trip_step, 'Location': 'Depot', 'Action': 'End Shift (Empty)', 'Water': 0, 'Distance': dist_home})
        trip_step += 1
        current_node = 0

        # Switch Vehicle
        vehicle_idx += 1
        v_name, v_shift = get_current_vehicle_info(vehicle_idx)
        # Note: New vehicle starts loop with current_water = 0, triggering Refill Trip logic.

if current_node != 0:
    dist_home = dist_matrix[current_node, 0]
    log_rows.append({'Vehicle': v_name, 'Shift': v_shift, 'Step': trip_step, 'Location': 'Depot', 'Action': 'End Shift', 'Water': current_water, 'Distance': dist_home})

final_df = pd.DataFrame(log_rows)
final_df.to_csv('solution_relay_shift_ordered.csv', index=False)
print("Solution Saved: solution_relay_shift_ordered.csv")
print(final_df.head(10))

"""**Reasoning**:
The previous steps successfully re-generated the relay solution based on the increased GA generations. Now, I need to update the route map visualization to reflect this new, potentially more optimal, solution. This involves re-running the plotting code to generate a new map image.


"""

import matplotlib.pyplot as plt
import matplotlib.cm as cm

# --- 6. Plotting ---
plt.figure(figsize=(12, 10))
plt.scatter(park_nodes['lon'], park_nodes['lat'], c='green', label='Taman', s=30, alpha=0.6)
r_nodes = nodes_df[nodes_df['type']=='refill']
plt.scatter(r_nodes['lon'], r_nodes['lat'], c='blue', marker='s', label='Refill', s=30, alpha=0.6)
plt.scatter(depot['lon'], depot['lat'], c='red', marker='*', label='Depot', s=200, zorder=10)

name_coord_map = dict(zip(nodes_df['name'], zip(nodes_df['lon'], nodes_df['lat'])))
name_coord_map['Depot'] = (depot.lon, depot.lat)

unique_vehicles = final_df['Vehicle'].unique()
colors = cm.get_cmap('tab20', len(unique_vehicles))

for i, v in enumerate(unique_vehicles):
    v_data = final_df[final_df['Vehicle'] == v]
    path_lons = []
    path_lats = []

    for _, row in v_data.iterrows():
        loc = row['Location']
        if loc in name_coord_map:
            path_lons.append(name_coord_map[loc][0])
            path_lats.append(name_coord_map[loc][1])

    plt.plot(path_lons, path_lats, color=colors(i), linewidth=1.5, alpha=0.7, label=v if i < 10 else None)

plt.title('Peta Rute Estafet (Shift) Penyiraman')
plt.xlabel('Longitude')
plt.ylabel('Latitude')
handles, labels = plt.gca().get_legend_handles_labels()
by_label = dict(zip(labels, handles))
plt.legend(by_label.values(), by_label.keys(), bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.grid(True, alpha=0.3)
plt.savefig('vrp_relay_map_final.png')
plt.show()

"""**Reasoning**:
The previous plotting code generated a `MatplotlibDeprecationWarning` because `cm.get_cmap` is deprecated. I will update the code to use `plt.colormaps.get_cmap` and adjust the color indexing to resolve this warning.


"""

# ==========================================
# 7. HITUNG & TAMPILKAN TOTAL JARAK
# ==========================================
print("\n" + "="*40)
print("       RINGKASAN TOTAL JARAK")
print("="*40)

# Pastikan membaca file yang baru saja disimpan
try:
    df_result = pd.read_csv('solution_relay_shift_ordered.csv')

    dist_per_vehicle = df_result.groupby(['Vehicle', 'Shift'])['Distance'].sum().reset_index()

    dist_per_vehicle.rename(columns={'Distance': 'Total Jarak (km)'}, inplace=True)

    print("\n--- Total Jarak per Kendaraan ---")
    print(dist_per_vehicle.to_string(index=False))

    total_optimal_dist = df_result['Distance'].sum()

    print("\n" + "-"*40)
    print(f"TOTAL JARAK RUTE PALING OPTIMAL: {total_optimal_dist:.2f} km")
    print("-"*40)

except FileNotFoundError:
    print("File hasil tidak ditemukan. Pastikan proses sebelumnya sukses.")
except Exception as e:
    print(f"Terjadi kesalahan saat menghitung: {e}")

"""## Comparison of Total Optimal Distance

The Genetic Algorithm was re-run with an increased number of generations (from 40 to 100) to further optimize the sequence of parks to be watered.

- **Previous Total Optimal Distance (with 40 generations):** 383.69 km
- **New Total Optimal Distance (with 100 generations):** 379.88 km

By increasing the generations, the Genetic Algorithm found a slightly more optimal route, resulting in a reduction of **3.81 km** in the total distance required for all watering tasks. This indicates an improvement in the efficiency of the vehicle routing and assignment.
"""